using DataLocker.Properties;
using Microsoft.VisualBasic;
using System.Globalization;
using System.IO;
using System.Resources;
using System.Runtime.Versioning;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Text;

namespace Data_Locker
	{
	[SupportedOSPlatform ( "windows" )]
	public partial class dataLockerForm : Form
		{
		public dataLockerForm( )
			{
			/// <summary>
			/// Prefer .NET 5 or greater.
			/// </summary>
#if NET5_0_OR_GREATER
			InitializeComponent ( );
#endif
			}
		private class ErrorLogging
			{
			public static void ErrorLog( System.Exception ex )
				{
				if (!File.Exists ( "ErrorLog.txt" ))
					File.Create ( "ErrorLog.txt" ).Dispose ( );

				try
					{
					using (StreamWriter Writer = File.AppendText ( "ErrorLog.txt" ))
						{
						Writer.AutoFlush = true;
						Writer.Write ( DateTime.Now + " " );
						Writer.Write ( ex.Message );
						Writer.Write ( ex.InnerException );
						Writer.Write ( ex.StackTrace );
						Writer.WriteLine ( );
						Writer.WriteLine ( );
						}
					}
				catch (ArgumentException e)
					{
					if (ex.InnerException == null || ex.StackTrace == null || ex.Message == null)
						ErrorLog ( e );
					}
				}
			}

		#region Cryptographic Functions
		private static class Crypto
			{
			/// <summary>
			/// Create cryptography classes
			/// </summary>
			private static RandomNumberGenerator rndNum = RandomNumberGenerator.Create ( );
			private static readonly Aes aes = Aes.Create ( );
			/// <summary>
			/// Hash and salt sizes.
			/// </summary>
			private const int HashBitSize = 512;
			private const int SaltBitSize = 512;
			private static byte[] SaltBytes = new byte[SaltBitSize / 8];
			private static byte[]? HashBytes = new byte[HashBitSize / 8];
			private static byte[] hashSalt = Array.Empty<byte> ( );
			private static byte[] HashedValue = Array.Empty<byte> ( );
			/// <summary>
			/// AES values.
			/// </summary>
			private const int BlockBitSize = 128;
			private const int KeyBitSize = 256;
			private const int IVBit = 128;
			/// <summary>
			/// Generates a random alphabetical numerical string that includes special characters. This is
			/// used to generate a random key value.
			/// </summary>
			/// <param name="size">How many characters the string should be.</param>
			/// <returns>A random string based on the parameter "Size".</returns>
			public static string generateRndString( int size )
				{
				string result = string.Empty;
				char[] alphaNumeric = @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-_=+[{]};:'|""\<,.>/?".ToCharArray ( );

				for (int i = 0; i < size; i++)
					{
					int index = boundedInt ( 0, alphaNumeric.Length );
					result += alphaNumeric[index];
					}
				return result;
				}
			/// <summary>
			/// Generates a random integer using the random number generator class.
			/// </summary>
			/// <returns>A random integer without bounds.</returns>
			private static int rndInt( )
				{
				int size = 4;
				byte[] buffer = new byte[(sizeof ( int ))];
				rndNum.GetBytes ( buffer );
				int result = BitConverter.ToInt32 ( buffer, 0 );
				return result;
				}
			/// <summary>
			/// Generates a random integer that is bounded with a minimum and maximum value. Seed value
			/// is generated by calling generate random integer. Based on the random number generator class.
			/// </summary>
			/// <param name="min">The minimum value to be generated.</param>
			/// <param name="max">The maximum value to be generated.</param>
			/// <returns></returns>
			private static int boundedInt( int min, int max )
				{
				var seed = rndInt ( );
#pragma warning disable
				return new Random ( ).Next ( min, max );
#pragma warning restore
				}
			/// <summary>
			/// Generates a random byte array that's determined by the parameter "Size".
			/// </summary>
			/// <param name="size">The size of the byte array to create.</param>
			/// <returns>A random byte array that is determined by the parameter "Size".</returns>
			private static byte[] rndByteSized( int size )
				{
				var buffer = new byte[size];
				rndNum.GetBytes ( buffer );
				return buffer;
				}
			/// <summary>
			/// Computes the hash value of a byte array, with a specified offset and length.
			/// </summary>
			/// <param name="Input">Byte array to compute hash.</param>
			/// <param name="offset">Offset within the byte array to start the process.</param>
			/// <param name="len">The length of the byte array to compute a hash value.</param>
			/// <returns></returns>
			private static byte[]? GetHashValue( byte[] Input, int offset, int len )
				{
				using (HMACSHA512 hash = new HMACSHA512 ( hashSalt ))
					{
					HashedValue = hash.ComputeHash ( Input, offset, len );
					}
				if (HashedValue != null)
					{
					return HashedValue;
					}
				return null;
				}

			/// <summary>
			/// Encrypts a string.
			/// </summary>
			/// <param name="PlainText">The plain text to encrypt.</param>
			/// <param name="Key">The key used for encryption.</param>
			/// <returns>An encrypted string in the format of Base64.</returns>
#pragma warning disable
			public static byte[]? Encrypt( byte[]? PlainText, byte[]? Key )
				{
				///<remarks>Set up variables.
				///<remarks>Set up variables.
				var IV = rndByteSized ( IVBit / 8 );
				SaltBytes = rndByteSized ( SaltBitSize / 8 );
				byte[] CipherText = Array.Empty<byte> ( );
				hashSalt = rndByteSized ( HashBitSize / 8 );
				///</remarks>
				///<remarks>Check parameters.
				///
				try
					{
					/// </remarks>
					///<remarks>Set up parameters for AES.
					using (aes)
						{
						aes.BlockSize = BlockBitSize;
						aes.KeySize = KeyBitSize;
						aes.Mode = CipherMode.CBC;
						aes.Padding = PaddingMode.PKCS7;
						};
					///	</remarks>	
					///	
					///<remarks>Begin encryption.
#pragma warning disable CA5401
					using (var Encryptor = aes.CreateEncryptor ( Key, IV ))
#pragma warning restore CA5401
					using (var memStream = new MemoryStream ( ))
						{
						using (var CryptoStream = new CryptoStream ( memStream, Encryptor, CryptoStreamMode.Write ))
						using (var encryptStream = new MemoryStream ( PlainText ))
							{
							encryptStream.CopyTo ( CryptoStream, encryptStream.Capacity );
							CryptoStream.FlushFinalBlock ( );
							encryptStream.Flush ( );
							CryptoStream.Clear ( );
							}
						CipherText = memStream.ToArray ( );
						}
					}

				///<summary>Catch blocks.</summary>
				///

				catch (OutOfMemoryException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					System.Windows.Forms.MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return null;
					}
				catch (ArgumentException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					System.Windows.Forms.MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return null;
					}
				catch (CryptographicException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					System.Windows.Forms.MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return null;
					}
				catch (IOException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					System.Windows.Forms.MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return null;
					}

				try
					{
					byte[] prependItems = new byte[IV.Length + SaltBytes.Length + CipherText.Length + HashBytes!.Length];
					using (var encryptStream = new MemoryStream ( prependItems ))
						{
						Buffer.BlockCopy ( IV, 0, prependItems, 0, IV.Length );
						Buffer.BlockCopy ( SaltBytes, 0, prependItems, IV.Length, SaltBytes.Length );
						Buffer.BlockCopy ( CipherText, 0, prependItems, IV.Length + SaltBytes.Length, CipherText.Length );

						HashBytes = GetHashValue ( prependItems, 0, prependItems.Length );
						Buffer.BlockCopy ( HashBytes!, 0, prependItems, IV.Length + SaltBytes.Length + CipherText.Length, HashBytes!.Length );
						prependItems.CopyTo ( encryptStream.ToArray ( ), 0 );
						Key = null;
						return encryptStream.ToArray ( );
						}
					}
				catch (System.Exception ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					System.Windows.Forms.MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return null; ;
					}
				return null;
				}
			/// </summary>
			/// <summary>
			/// Decrypts a string.
			/// </summary>
			/// <param name="CipherText">Text to decrypt.</param>
			/// <param name="Key">Key used for encryption and decryption.</param>
			/// <returns>Decrypted string and hash value. </returns>
			public static (byte[]? PlainText, byte[]? HashedBytes) Decrypt( byte[]? CipherText, byte[]? Key )
				{
				try
					{
					using (var HMAC = new HMACSHA512 ( hashSalt ))
						{
						var sentHash = new byte[HashBytes!.Length];
						if (CipherText == null)
							{
							return (null, null);
							}

						byte[] getHash = new byte[HashBytes.Length];

						Buffer.BlockCopy ( CipherText, CipherText.Length - HashBytes.Length, getHash, 0, HashBytes.Length );
						Buffer.BlockCopy ( CipherText, CipherText.Length - HashBytes.Length, sentHash, 0, HashBytes.Length );

						bool hashCompare = CryptographicOperations.FixedTimeEquals ( sentHash, getHash );
						if (!hashCompare)
							{
							System.Windows.Forms.MessageBox.Show ( "There was an error comparing hash values.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
							return (null, null);
							}
						///<remarks>Set up parameters for AES.
						///</remarks>
						using (aes)
							{
							aes.BlockSize = BlockBitSize;
							aes.KeySize = KeyBitSize;
							aes.Mode = CipherMode.CBC;
							aes.Padding = PaddingMode.PKCS7;
							};

						var IV = new byte[IVBit / 8];

						//Grab IV
						Buffer.BlockCopy ( CipherText, 0, IV, 0, IV.Length );

						var ciphertextOffset = SaltBytes.Length + IV.Length;
						var hashOffset = CipherText.Length - HashBytes.Length;
						var hashResult = new byte[HashBytes.Length];
						var cipherResult = new byte[CipherText.Length - SaltBytes.Length - IV.Length - hashResult.Length];

						Buffer.BlockCopy ( CipherText, ciphertextOffset, cipherResult, 0, cipherResult.Length );
						Buffer.BlockCopy ( CipherText, hashOffset, hashResult, 0, hashResult.Length );
						///<remarks>Begin decryption.</remarks>
						///
						using (var decryptor = aes.CreateDecryptor ( Key, IV ))
						using (var memStrm = new MemoryStream ( ))
							{
							using (var decryptStream = new CryptoStream ( memStrm, decryptor, CryptoStreamMode.Write ))
							using (var plainTextStream = new MemoryStream ( cipherResult ))
								{
								plainTextStream.CopyTo ( decryptStream, plainTextStream.Capacity );
								}
							return (memStrm.ToArray ( ), hashResult);
							}
						}
					}
				catch (System.Exception ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					System.Windows.Forms.MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return (null, null);
					}
				}
			}
		#endregion
#pragma warning restore

		#region Data Conversion Methods
		private static class DataConversionHelpers
			{
			private static readonly CultureInfo cultureInfo = CultureInfo.CurrentCulture;
			public static string Input = string.Empty;
			public static byte[] Buffer = Array.Empty<byte> ( );
			public static string? ByteArrayToHexString( byte[] Buffer )
				{
				if (Buffer == null)
					return null;
				return Convert.ToHexString ( Buffer, 0, Buffer.Length ).ToLower ( cultureInfo );
				}
			public static byte[]? HexStringToByteArray( string Input )
				{
				if (string.IsNullOrWhiteSpace ( Input ))
					return null;
				return Encoding.UTF8.GetBytes ( Input );
				}
			public static string? StringToHex( byte[] Buffer )
				{
				if (Buffer == null)
					return null;
				return Convert.ToHexString ( Buffer, 0, Buffer.Length ).ToLower ( cultureInfo );
				}
			public static string? ByteArrayToString( byte[] Buffer )
				{
				if (Buffer == null)
					return null;
				return Encoding.UTF8.GetString ( Buffer );
				}
			public static byte[]? StringToByteArray( string Input )
				{
				if (string.IsNullOrWhiteSpace ( Input ))
					return null;
				return Encoding.UTF8.GetBytes ( Input );
				}
			public static string? ByteArrayToBase64String( byte[] Buffer )
				{
				if (Buffer == null)
					return null;
				return Convert.ToBase64String ( Buffer, 0, Buffer.Length );
				}
			public static byte[]? Base64StringToByteArray( string Input )
				{
				if (string.IsNullOrWhiteSpace ( Input ))
					return null;
				return Convert.FromBase64String ( Input );
				}
			}


		#endregion

		private static string? loadedFile = string.Empty;
		private static ToolTip toolTip = new ToolTip ( );
		private static bool fileOpened;
		/// <summary>
		/// Why is this even a thing? Anyways, added to suppress warnings.
		/// </summary>
		ResourceManager resourceManager = new ResourceManager ( "DataLocker.Properties.Resources", typeof ( Resources ).Assembly );
		public static ToolTip tip
			{
			get { return toolTip; }
			set { toolTip = value; }
			}

#pragma warning disable
		public string? Encrypt( string data, byte[] key )
			{
			byte[] plainText = DataConversionHelpers.StringToByteArray ( data );
			try
				{
				var cipherText = Crypto.Encrypt ( plainText, key );
				if (cipherText == null)
					throw new CryptographicException ( "Value returned null.", nameof ( cipherText ) );
				return DataConversionHelpers.ByteArrayToBase64String ( cipherText );
				}
			catch (CryptographicException ex)
				{
				ErrorMsg ( ex );
				ErrorLogging.ErrorLog ( ex );
				}
			return null;
			}

		(string? plainText, string? Hash) Decrypt( string data, byte[] key )
			{
			string? resultString = string.Empty;
			string? resultHash = string.Empty;

			var inputText = DataConversionHelpers.Base64StringToByteArray ( data );
			var result = Crypto.Decrypt ( inputText, key );

			if (result.PlainText == null)
				return (null, null);

			if (result.HashedBytes == null)
				return (null, null);

			resultString = DataConversionHelpers.ByteArrayToString ( result.PlainText );
			resultHash = DataConversionHelpers.ByteArrayToHexString ( result.HashedBytes );

			return (resultString, resultHash);
			}
		private void encryptBtn_Click( object sender, EventArgs e )
			{
			string inputString = loadedFile;
			string keyString = keyTxtBox.Text;
			byte[] Key = Encoding.UTF8.GetBytes ( keyTxtBox.Text );
			string? encryptData = loadedFile;
			try
				{
				if (string.IsNullOrEmpty ( keyString ))
					throw new ArgumentException ( "Key value was empty or null.", nameof ( Key ) );
				if (string.IsNullOrEmpty ( inputString ))
					throw new ArgumentException ( "Input value was empty or null.", nameof ( inputString ) );
				encryptData = Encrypt ( inputString, Key );
				loadedFile = encryptData;
				fileStatusOutput.Text = "File Encrypted! New byte size: " + loadedFile.Length + " bytes!";
				if (string.IsNullOrEmpty ( encryptData ))
					throw new System.Exception ( "Encryption value returned empty or null." );
				}
			catch (ArgumentException ex)
				{
				ErrorLogging.ErrorLog ( ex );
				ErrorMsg ( ex );
				return;
				}
			catch (System.Exception ex)
				{
				ErrorLogging.ErrorLog ( ex );
				ErrorMsg ( ex );
				return;
				}
			encryptData = null;
			}
		private void decryptBtn_Click( object sender, EventArgs e )
			{
			string inputData = loadedFile;
			byte[] Key = Encoding.UTF8.GetBytes ( keyTxtBox.Text );
			(string? plainText, string? HashedValue) Text;
			try
				{
				if (Key == null)
					throw new ArgumentException ( "Value was empty or null.", nameof ( Key ) );
				if (Key.Length != 256 / 8)
					throw new ArgumentException ( "Key must be 256 bits.", nameof ( Key ) );
				if (string.IsNullOrEmpty ( inputData ))
					throw new ArgumentException ( "Value was empty or null.", nameof ( inputData ) );
				Text = Decrypt ( inputData, Key );
				if (string.IsNullOrEmpty ( Text.plainText ))
					throw new System.Exception ( "Value was empty or null." );
				if (string.IsNullOrEmpty ( Text.HashedValue ))
					throw new System.Exception ( "Value was empty or null." );
				fileStatusOutput.Text = "File Decrypted! New byte size: " + loadedFile.Length + " bytes!";
				loadedFile = Text.plainText + "\n" + "Hash: " + Text.HashedValue;
				hashBoxTxt.Text = Text.HashedValue;
				}
			catch (ArgumentException ex)
				{
				ErrorLogging.ErrorLog ( ex );
				ErrorMsg ( ex );
				return;
				}
			catch (System.Exception ex)
				{
				ErrorLogging.ErrorLog ( ex );
				ErrorMsg ( ex );
				return;
				}
			Text = (null, null);
			}

#pragma warning restore
		private void generateRnd32_Click( object sender, EventArgs e )
			{
			keyTxtBox.Text = Crypto.generateRndString ( 32 );
			}
		private void generateRnd32_MouseHover( object sender, EventArgs e )
			{
			tip.InitialDelay = 1000;
			tip.ToolTipIcon = ToolTipIcon.Info;
			tip.ReshowDelay = 1000;
			tip.UseAnimation = true;
			tip.UseFading = true;
			tip.ToolTipTitle = "Info";
			tip.Show ( "Generates a random alphabetical-numerical string which also contains \n" +
"special characters. The key is symmetrical meaning you will need to use it to decrypt \n" +
"the ciphertext back to readable text.", generateRnd32, int.MaxValue );
			}

		private void copyHash_Click( object sender, EventArgs e )
			{
			Clipboard.SetText ( hashBoxTxt.Text );
			}

		private void encryptBtn_MouseHover( object sender, EventArgs e )
			{
			tip.InitialDelay = 1000;
			tip.ToolTipIcon = ToolTipIcon.Info;
			tip.ReshowDelay = 1000;
			tip.UseAnimation = true;
			tip.UseFading = true;
			tip.ToolTipTitle = "Info";
			tip.Show ( "Encrypts the input text with the \n" +
				"provided key to a cipher text that is in Base64 format or Hexadecimal.", encryptBtn, int.MaxValue );
			}

		private void decryptBtn_MouseHover( object sender, EventArgs e )
			{
			tip.InitialDelay = 1000;
			tip.ToolTipIcon = ToolTipIcon.Info;
			tip.ReshowDelay = 1000;
			tip.UseAnimation = true;
			tip.UseFading = true;
			tip.ToolTipTitle = "Info";
			tip.Show ( "Decrypts the input text with the \n" +
				"provided key back to the selected format and outputs a hash value.", decryptBtn, int.MaxValue );
			}
		public void ErrorMsg( System.Exception e )
			{
			if (e == null)
				{
				throw new ArgumentNullException ( nameof ( e ), "Exception value was null." );
				ErrorLogging.ErrorLog ( e );
				}
			Invoke ( ( ) => { errorLoggingTxt.AppendText ( e.Message ); } );
			if (e.InnerException != null)
				Invoke ( ( ) => { errorLoggingTxt.AppendText ( e.InnerException.ToString ( ) ); } );
			if (e.StackTrace != null)
				Invoke ( ( ) => { errorLoggingTxt.AppendText ( e.StackTrace ); } );
			errorLoggingTxt.AppendText ( DateAndTime.Now.ToString ( ) + " " + Environment.NewLine + Environment.NewLine +
				e.Message + " " + Environment.NewLine + Environment.NewLine + " " );
			if (e.InnerException != null)
				errorLoggingTxt.AppendText ( e.StackTrace + " " + Environment.NewLine +
			Environment.NewLine + " " + "" );
			if (e.StackTrace != null)
				errorLoggingTxt.AppendText ( e.StackTrace + " " + Environment.NewLine +
				Environment.NewLine + " " + "" );
			}
		private void openFile_Click( object sender, EventArgs e )
			{
			using var openFileDialog = new OpenFileDialog ( );
			openFileDialog.Filter = resourceManager.GetString ( "file types", CultureInfo.CurrentUICulture );
			openFileDialog.RestoreDirectory = true;
			openFileDialog.FilterIndex = 2;
			openFileDialog.ShowHiddenFiles = true;
			openFileDialog.CheckFileExists = true;
			openFileDialog.CheckPathExists = true;
			GCCollectionMode gcCollectionMode = GCCollectionMode.Aggressive;
			if (openFileDialog.ShowDialog ( ) == DialogResult.OK)
				{
				try
					{
					string openedFile = openFileDialog.FileName;
					string compare = Path.GetExtension ( openedFile );
					if (compare != ".txt")
						throw new ArgumentException ( "Invalid file type.", openFileDialog.FileName );
					string fileName = openFileDialog.FileName;
					const int maxSize = 800_000_000;
					FileInfo info = new FileInfo ( fileName );
#pragma warning disable
					if (info.Length > maxSize)
						throw new OutOfMemoryException ( "Value exceeded maximum value." );
#pragma warning restore
					byte[] buffer = Array.Empty<byte> ( );
					StringBuilder sb = new StringBuilder ( );
					using (var fs = new FileStream ( fileName, FileMode.Open, FileAccess.Read ))
						{
						buffer = new byte[fs.Length];
						int bytesRead = 0;
						bytesRead = fs.Read ( buffer, 0, buffer.Length );
						GC.Collect ( );
						var memstrm = new MemoryStream ( buffer );
						buffer.CopyTo ( memstrm.ToArray ( ), 0 );
						loadedFile = sb.Append ( Encoding.UTF8.GetString ( memstrm.ToArray ( ) ) ).ToString ( );
						fileOpened = true;
						}
					if (!fileOpened)
						{
						fileStatusOutput.Text = resourceManager.GetString ( "errorloadfile", CultureInfo.CurrentUICulture );
						fileStatusOutput.ForeColor = Color.Red;
						}
					MessageBox.Show ( "File Opened Successfully!", "Open File", MessageBoxButtons.OK, MessageBoxIcon.Information );
					fileStatusOutput.Text = "File Loaded! File size: " + info.Length.ToString ( ) + " bytes!";
					fileStatusOutput.ForeColor = Color.LimeGreen;
					}
				catch (OutOfMemoryException ex)
					{
					errorLoggingTxt.Text = ex.Message;
					ErrorLogging.ErrorLog ( ex );
					return;
					}
				catch (ArgumentException ex)
					{
					errorLoggingTxt.Text = ex.Message;
					ErrorLogging.ErrorLog ( ex );
					fileStatusOutput.Text = resourceManager.GetString ( "errorfileload" );
					fileStatusOutput.ForeColor = Color.Red;
					return;
					}
				catch (FileNotFoundException ex)
					{
					errorLoggingTxt.Text = ex.Message;
					ErrorLogging.ErrorLog ( ex );
					return;
					}
				catch (IOException ex)
					{
					errorLoggingTxt.Text = ex.Message;
					ErrorLogging.ErrorLog ( ex );
					return;
					}
				}
			}

		private void saveFile_Click( object sender, EventArgs e )
			{
			try
				{
				if (!fileOpened)
					throw new ArgumentException ( );
				using var sf = new SaveFileDialog ( );
				sf.Filter = resourceManager.GetString ( "file types", CultureInfo.CurrentUICulture );
				sf.FileName = sf.FileName;
				sf.RestoreDirectory = true;
				sf.FilterIndex = 1;
				sf.ShowHiddenFiles = true;
				if (sf.ShowDialog ( ) == DialogResult.OK)
					{
					FileIOPermissionAccess fileSystemSecurity;
					fileSystemSecurity = FileIOPermissionAccess.Write;
					sf.CreatePrompt = true;
					sf.CheckWriteAccess = true;
					sf.CheckFileExists = true;
					sf.CheckPathExists = true;
					using (StreamWriter sw = new StreamWriter ( sf.FileName ))
						{
						sw.Write ( loadedFile );
						}
					MessageBox.Show ( "File Saved Successfully!", "Save File", MessageBoxButtons.OK, MessageBoxIcon.Information );
					fileStatusOutput.Text = resourceManager.GetString ( "status", CultureInfo.CurrentUICulture );
					fileStatusOutput.ForeColor = Color.WhiteSmoke;
					loadedFile = null;
					fileOpened = false;
					}
				}
			catch (ArgumentException ex)
				{
				errorLoggingTxt.Text = ex.Message;
				ErrorLogging.ErrorLog ( ex );
				return;
				}
			catch (IOException ex)
				{
				errorLoggingTxt.Text = ex.Message;
				ErrorLogging.ErrorLog ( ex );
				return;
				}
			}

		private void clrErrors_Click( object sender, EventArgs e )
			{
			errorLoggingTxt.Clear ( );
			}
		}
	}

