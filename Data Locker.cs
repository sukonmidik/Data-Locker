using System.Globalization;
using System.Security.Cryptography;
using System.Text;

namespace Data_Locker
	{
	public partial class dataLockerForm : Form
		{
		public dataLockerForm( )
			{
			/// <summary>
			/// Prefer .NET 5 or greater.
			/// </summary>
#if NET5_0_OR_GREATER
			InitializeComponent ( );
#endif
			}
		private static class ErrorLogging
			{
			public static void ErrorLog( Exception ex )
				{
				if (!File.Exists ( "ErrorLog.txt" ))
					File.Create ( "ErrorLog.txt" ).Dispose ( );

				using (StreamWriter Writer = File.AppendText ( "ErrorLog.txt" ))
					{
					Writer.AutoFlush = true;
					Writer.Write ( DateTime.Now + " " );
					Writer.Write ( ex.Message );
					Writer.Write ( ex.InnerException );
					Writer.Write ( ex.StackTrace );
					Writer.WriteLine ( );
					Writer.WriteLine ( );
					}
				}
			}

		#region Cryptographic Functions
		private static class Crypto
			{
			/// <summary>
			/// Declare cryptography namespaces
			/// </summary>
			private static RandomNumberGenerator rndNum = RandomNumberGenerator.Create ( );
			private static readonly Aes aes = Aes.Create ( );
			/// <summary>
			/// Hash and salt sizes.
			/// </summary>
			private const int HashBitSize = 512;
			private const int SaltBitSize = 512;
			private static byte[] SaltBytes = new byte[SaltBitSize / 8];
			private static byte[]? HashBytes = new byte[HashBitSize / 8];
			private static byte[] hashSalt = Array.Empty<byte> ( );
			private static byte[] HashedValue = Array.Empty<byte> ( );
			/// <summary>
			/// AES values.
			/// </summary>
			private const int BlockBitSize = 128;
			private const int KeyBitSize = 256;
			private const int IVBit = 128;
			/// <summary>
			/// Generates a random alphabeticalnumerical string that includes special characters. This is
			/// used to generate a random key value.
			/// </summary>
			/// <param name="size">How many characters the string should be.</param>
			/// <returns>A random string based on the parameter "Size".</returns>
			public static string generateRndString( int size )
				{
				string result = string.Empty;
				char[] alphaNumeric = @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-_=+[{]};:'|""\<,.>/?".ToCharArray ( );

				for (int i = 0; i < size; i++)
					{
					int index = boundedInt ( 0, alphaNumeric.Length );
					result += alphaNumeric[index];
					}
				return result;
				}
			/// <summary>
			/// Generates a random integer using the random number generator class.
			/// </summary>
			/// <returns>A random integer without bounds.</returns>
			private static int rndInt( )
				{
				byte[] buffer = new byte[(sizeof ( int ))];
				rndNum.GetBytes ( buffer );
				int result = BitConverter.ToInt32 ( buffer, 0 );
				return result;
				}
			/// <summary>
			/// Generates a random integer that is bounded with a minimum and maximum value. Seed value
			/// is generated by calling generate random integer. Based on the random number generator class.
			/// </summary>
			/// <param name="min">The minimum value to be generated.</param>
			/// <param name="max">The maximum value to be generated.</param>
			/// <returns></returns>
			private static int boundedInt( int min, int max )
				{
				var seed = rndInt ( );
#pragma warning disable
				return new Random ( ).Next ( min, max );
#pragma warning restore
				}
			/// <summary>
			/// Generates a random byte array thats determined by the parameter "Size".
			/// </summary>
			/// <param name="size">The size of the byte array to create.</param>
			/// <returns>A random byte array that is determined by the parameter "Size".</returns>
			private static byte[] rndByteSized( int size )
				{
				var buffer = new byte[size];
				rndNum.GetBytes ( buffer );
				return buffer;
				}
			/// <summary>
			/// Computes the hash value of a byte array, with a specified offset and length.
			/// </summary>
			/// <param name="Input">Byte array to compute hash.</param>
			/// <param name="offset">Offset within the byte array to start the process.</param>
			/// <param name="len">The length of the byte array to compute a hash value.</param>
			/// <returns></returns>
			private static byte[]? GetHashValue( byte[] Input, int offset, int len )
				{
				using (HMACSHA512 hash = new HMACSHA512 ( hashSalt ))
					{
					HashedValue = hash.ComputeHash ( Input, offset, len );
					}
				if (HashedValue != null)
					{
					return HashedValue;
					}
				return null;
				}

			/// <summary>
			/// Encrypts a string.
			/// </summary>
			/// <param name="PlainText">The plain text to encrypt.</param>
			/// <param name="Key">The key used for encryption.</param>
			/// <returns>An encrypted string in the format of Base64.</returns>
			public static byte[]? Encrypt( byte[]? PlainText, byte[]? Key )
				{
				///<remarks>Set up variables.
				var IV = rndByteSized ( IVBit / 8 );
				SaltBytes = rndByteSized ( SaltBitSize / 8 );
				byte[] CipherText = Array.Empty<byte> ( );
				hashSalt = rndByteSized ( HashBitSize / 8 );
				///</remarks>
				///<remarks>Check parameters.
				///
				try
					{
					if (Key?.Length != KeyBitSize / 8)
						throw new ArgumentException ( $"Keysize must be {KeyBitSize / 8} bits.", nameof ( Key ) );
					if (PlainText == null || PlainText.Length < 1)
						throw new ArgumentException ( "You must enter text to be decrypted.", nameof ( PlainText ) );
					/// </remarks>
					///<remarks>Set up parameters for AES.
					using (aes)
						{
						aes.BlockSize = BlockBitSize;
						aes.KeySize = KeyBitSize;
						aes.Mode = CipherMode.CBC;
						aes.Padding = PaddingMode.PKCS7;
						};
					///	</remarks>	
					///	
					///<remarks>Begin encryption.
#pragma warning disable CA5401
					using (var Encryptor = aes.CreateEncryptor ( Key, IV ))
#pragma warning restore CA5401
					using (var memStream = new MemoryStream ( ))
						{
						using (var CryptoStream = new CryptoStream ( memStream, Encryptor, CryptoStreamMode.Write ))
						using (var encryptStream = new MemoryStream ( PlainText ))
							{
							encryptStream.CopyTo ( CryptoStream, encryptStream.Capacity );
							CryptoStream.FlushFinalBlock ( );
							encryptStream.Flush ( );
							CryptoStream.Clear ( );
							}
						CipherText = memStream.ToArray ( );
						}
					}

				///<summary>Catch blocks.</summary>
				catch (ArgumentException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return null;
					}
				catch (CryptographicException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return null;
					}
				catch (IOException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return null;
					}
				catch (NotSupportedException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return null;
					}
				catch (OutOfMemoryException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					return null;
					}

				try
					{
					byte[] prependItems = new byte[IV.Length + SaltBytes.Length + CipherText.Length + HashBytes!.Length];
					using (var encryptStream = new MemoryStream ( prependItems ))
						{
						Buffer.BlockCopy ( IV, 0, prependItems, 0, IV.Length );
						Buffer.BlockCopy ( SaltBytes, 0, prependItems, IV.Length, SaltBytes.Length );
						Buffer.BlockCopy ( CipherText, 0, prependItems, IV.Length + SaltBytes.Length, CipherText.Length );

						HashBytes = GetHashValue ( prependItems, 0, prependItems.Length );
						Buffer.BlockCopy ( HashBytes!, 0, prependItems, IV.Length + SaltBytes.Length + CipherText.Length, HashBytes!.Length );
						prependItems.CopyTo ( encryptStream.ToArray ( ), 0 );
						Key = null;
						return encryptStream.ToArray ( );
						}
					}

				catch (ArgumentNullException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException + " " + ex.ParamName;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					}
				catch (ArgumentException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException + " " + ex.ParamName;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					}
				catch (Exception ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					}
				return null;
				}
			/// </summary>
			/// <summary>
			/// Decrypts a string.
			/// </summary>
			/// <param name="CipherText">Text to decrypt.</param>
			/// <param name="Key">Key used for encryption and decryption.</param>
			/// <returns>Decrypted string and hash value. </returns>
			public static (byte[]? PlainText, byte[]? HashedBytes) Decrypt( byte[]? CipherText, byte[]? Key )
				{
				///<remarks>Check parameters.</remarks>
				if (Key?.Length != KeyBitSize / 8)
					throw new ArgumentException ( string.Format ( $"Key needs to be {KeyBitSize} bits.", "Encryption key." ) );
				if (CipherText == null)
					ArgumentException.ThrowIfNullOrEmpty ( "PlainText", nameof ( CipherText ) );
				if (Key == null)
					ArgumentException.ThrowIfNullOrEmpty ( "Key", nameof ( Key ) );
				///
				try
					{
					using (var HMAC = new HMACSHA512 ( hashSalt ))
						{
						var sentHash = new byte[HashBytes!.Length];
						if (CipherText == null)
							{
							return (null, null);
							}

						byte[] getHash = new byte[HashBytes.Length];

						Buffer.BlockCopy ( CipherText, CipherText.Length - HashBytes.Length, getHash, 0, HashBytes.Length );
						Buffer.BlockCopy ( CipherText, CipherText.Length - HashBytes.Length, sentHash, 0, HashBytes.Length );

						bool hashCompare = CryptographicOperations.FixedTimeEquals ( sentHash, getHash );
						if (!hashCompare)
							{
							MessageBox.Show ( "There was an error comparing hash values." );
							return (null, null);
							}
						///<remarks>Set up parameters for AES.
						///</remarks>
						using (aes)
							{
							aes.BlockSize = BlockBitSize;
							aes.KeySize = KeyBitSize;
							aes.Mode = CipherMode.CBC;
							aes.Padding = PaddingMode.PKCS7;
							};

						var IV = new byte [IVBit / 8];

						//Grab IV
						Buffer.BlockCopy ( CipherText, 0, IV, 0, IV.Length );

						var ciphertextOffset = SaltBytes.Length + IV.Length;
						var hashOffset = CipherText.Length - HashBytes.Length;
						var hashResult = new byte[HashBytes.Length];
						var cipherResult = new byte[CipherText.Length - SaltBytes.Length - IV.Length - hashResult.Length];

						Buffer.BlockCopy ( CipherText, ciphertextOffset, cipherResult, 0, cipherResult.Length );
						Buffer.BlockCopy ( CipherText, hashOffset, hashResult, 0, hashResult.Length );
						///<remarks>Begin decryption.</remarks>
						///
						if (Key == null)
							return (null, null);
						using (var decryptor = aes.CreateDecryptor ( Key, IV ))
						using (var memStrm = new MemoryStream ( ))
							{
							using (var decryptStream = new CryptoStream ( memStrm, decryptor, CryptoStreamMode.Write ))
							using (var plainTextStream = new MemoryStream ( cipherResult ))
								{
								plainTextStream.CopyTo( decryptStream, plainTextStream.Capacity );
								}
							return (memStrm.ToArray ( ), hashResult);
							}
						}
					}
				catch (ArgumentException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					}
				catch (CryptographicException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					}
				catch (IOException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					}
				catch (NotSupportedException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					}
				catch (OutOfMemoryException ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					}
				catch (Exception ex)
					{
					ErrorLogging.ErrorLog ( ex );
					string error = ex.Message + " " + ex.InnerException;
					MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
					}
				return (null, null);
				}
			}
		#endregion

		#region Data Conversion Methods
		private static class DataConversionHelpers
			{
			private static readonly CultureInfo cultureInfo = CultureInfo.CurrentCulture;
			public static string? ByteArrayToHexString( byte[] Buffer )
				{
				if (Buffer == null)
					return null;
				return Convert.ToHexString ( Buffer, 0, Buffer.Length ).ToLower ( cultureInfo );
				}
			public static byte[]? HexStringToByteArray( string Input )
				{
				if (string.IsNullOrWhiteSpace ( Input ))
					return null;
				return Encoding.UTF8.GetBytes ( Input );
				}
			public static string? ByteArrayToString( byte[] Buffer )
				{
				if (Buffer == null)
					return null;
				return Encoding.UTF8.GetString ( Buffer );
				}
			public static byte[]? StringToByteArray( string Input )
				{
				if (string.IsNullOrWhiteSpace ( Input ))
					return null;
				return Encoding.UTF8.GetBytes ( Input );
				}
			public static string? ByteArrayToBase64String( byte[] Buffer )
				{
				if (Buffer == null)
					return null;
				return Convert.ToBase64String ( Buffer, 0, Buffer.Length );
				}
			public static byte[]? Base64StringToByteArray( string Input )
				{
				if (string.IsNullOrWhiteSpace ( Input ))
					return null;
				return Convert.FromBase64String ( Input );
				}
			}
		#endregion

		private static ToolTip toolTip = new ToolTip ( );
		public static ToolTip tip
			{
			get { return toolTip; }
			set { toolTip = value; }
			}
		public static string? Encrypt( string data, byte[] key )
			{
			try
				{
				ArgumentException.ThrowIfNullOrEmpty ( data );
				}
			catch (ArgumentException ex)
				{
				ErrorLogging.ErrorLog ( ex );
				string error = ex.Message + " " + ex.InnerException + " " + ex.ParamName;
				MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
				return null;
				}
			byte[]? plainText = DataConversionHelpers.StringToByteArray ( data );
			if (plainText == null)
				return null;
			var cipherText = Crypto.Encrypt ( plainText, key );
			if (cipherText == null)
				return null;
			return DataConversionHelpers.ByteArrayToBase64String ( cipherText );
			}
		public static (string? plainText, string? Hash) Decrypt( string data, byte[] key )
			{
			try
				{
				ArgumentException.ThrowIfNullOrEmpty ( data );
				}
			catch (ArgumentException ex)
				{
				ErrorLogging.ErrorLog ( ex );
				string error = ex.Message + " " + ex.InnerException + " " + ex.ParamName;
				MessageBox.Show ( error, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
				return (null, null);
				}
			var cipherText = DataConversionHelpers.Base64StringToByteArray ( data );
			var plaintext = Crypto.Decrypt ( cipherText, key );
			if (plaintext.PlainText == null)
				return (null, null);
			if (plaintext.HashedBytes == null)
				return (null, null);
			var plainTextTuple = DataConversionHelpers.ByteArrayToString ( plaintext.PlainText );
			var hashTextTuple = DataConversionHelpers.ByteArrayToHexString ( plaintext.HashedBytes );
			return (plainTextTuple, hashTextTuple);
			}
		private void encryptBtn_Click( object sender, EventArgs e )
			{
			string? encryptData = Encrypt ( inputTxtBox.Text, Encoding.UTF8.GetBytes ( keyTxtBox.Text ) );
			outputTxt.Text = encryptData;
			}
		private void decryptBtn_Click( object sender, EventArgs e )
			{
			var decryptData = Decrypt ( inputTxtBox.Text, Encoding.UTF8.GetBytes ( keyTxtBox.Text ) );
			outputTxt.Text = decryptData.plainText;
			hashBoxTxt.Text = decryptData.Hash;
			}
		private void generateRnd32_Click( object sender, EventArgs e )
			{
			keyTxtBox.Text = Crypto.generateRndString ( 32 );
			}
		private void generateRnd32_MouseHover( object sender, EventArgs e )
			{
			tip.InitialDelay = 1000;
			tip.ToolTipIcon = ToolTipIcon.Info;
			tip.ReshowDelay = 1000;
			tip.UseAnimation = true;
			tip.UseFading = true;
			tip.ToolTipTitle = "Info";
			tip.Show ( "Generates a random alphabetical-numerical string which also contains \n" +
"special characters. The key is symmetrical meaning you will need to use it to encrypt and decrypt \n" +
"information.", generateRnd32, int.MaxValue );
			}

		private void copyHash_Click( object sender, EventArgs e )
			{
			Clipboard.SetText ( hashBoxTxt.Text );
			}

		private void copyHash_MouseHover( object sender, EventArgs e )
			{
			tip.InitialDelay = 1000;
			tip.ToolTipIcon = ToolTipIcon.Info;
			tip.ReshowDelay = 1000;
			tip.UseAnimation = true;
			tip.UseFading = true;
			tip.ToolTipTitle = "Info";
			tip.Show ( "Copies the hash value that was generated during encryption. The hash value will always \n" +
				"be different even when using the same key.", copyHash, int.MaxValue );
			}

		private void encryptBtn_MouseHover( object sender, EventArgs e )
			{
			tip.InitialDelay = 1000;
			tip.ToolTipIcon = ToolTipIcon.Info;
			tip.ReshowDelay = 1000;
			tip.UseAnimation = true;
			tip.UseFading = true;
			tip.ToolTipTitle = "Info";
			tip.Show ( "Encrypts the input text with the \n" +
				"provided key to a cipher text that is in Base64 format.", encryptBtn, int.MaxValue );
			}

		private void decryptBtn_MouseHover( object sender, EventArgs e )
			{
			tip.InitialDelay = 1000;
			tip.ToolTipIcon = ToolTipIcon.Info;
			tip.ReshowDelay = 1000;
			tip.UseAnimation = true;
			tip.UseFading = true;
			tip.ToolTipTitle = "Info";
			tip.Show ( "Decrypts the input text with the \n" +
				"provided key back to the original text and outputs a hash value.", decryptBtn, int.MaxValue );
			}
		}
	}
